// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.27.1
// source: pkg/backoffice/main.proto

package backoffice

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Backoffice_HasAccess_FullMethodName                 = "/backoffice.Backoffice/HasAccess"
	Backoffice_GameList_FullMethodName                  = "/backoffice.Backoffice/GameList"
	Backoffice_GameListFull_FullMethodName              = "/backoffice.Backoffice/GameListFull"
	Backoffice_GetProvider_FullMethodName               = "/backoffice.Backoffice/GetProvider"
	Backoffice_HealthCheck_FullMethodName               = "/backoffice.Backoffice/HealthCheck"
	Backoffice_GetIntegratorGameSettings_FullMethodName = "/backoffice.Backoffice/GetIntegratorGameSettings"
	Backoffice_GetGameData_FullMethodName               = "/backoffice.Backoffice/GetGameData"
	Backoffice_GetGameDataByApi_FullMethodName          = "/backoffice.Backoffice/GetGameDataByApi"
	Backoffice_GetCurrencies_FullMethodName             = "/backoffice.Backoffice/GetCurrencies"
	Backoffice_GetMultiplierByCurrency_FullMethodName   = "/backoffice.Backoffice/GetMultiplierByCurrency"
	Backoffice_GetIntegratorApiKey_FullMethodName       = "/backoffice.Backoffice/GetIntegratorApiKey"
)

// BackofficeClient is the client API for Backoffice service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackofficeClient interface {
	HasAccess(ctx context.Context, in *HasAccessIn, opts ...grpc.CallOption) (*HasAccessOut, error)
	GameList(ctx context.Context, in *GameListIn, opts ...grpc.CallOption) (*GameListOut, error)
	GameListFull(ctx context.Context, in *GameListIn, opts ...grpc.CallOption) (*GameListOutFull, error)
	GetProvider(ctx context.Context, in *GetProviderIn, opts ...grpc.CallOption) (*GetProviderOut, error)
	HealthCheck(ctx context.Context, opts ...grpc.CallOption) (Backoffice_HealthCheckClient, error)
	GetIntegratorGameSettings(ctx context.Context, in *IntegratorGameSettingsIn, opts ...grpc.CallOption) (*IntegratorGameSettingsOut, error)
	GetGameData(ctx context.Context, in *GameDataByIntegratorName, opts ...grpc.CallOption) (*Game, error)
	GetGameDataByApi(ctx context.Context, in *HasAccessIn, opts ...grpc.CallOption) (*Game, error)
	GetCurrencies(ctx context.Context, in *CurrenciesIn, opts ...grpc.CallOption) (*CurrenciesOut, error)
	GetMultiplierByCurrency(ctx context.Context, in *GetMultiplierIn, opts ...grpc.CallOption) (*GetMultiplierOut, error)
	GetIntegratorApiKey(ctx context.Context, in *IntegratorApiKeyIn, opts ...grpc.CallOption) (*IntegratorApiKeyOut, error)
}

type backofficeClient struct {
	cc grpc.ClientConnInterface
}

func NewBackofficeClient(cc grpc.ClientConnInterface) BackofficeClient {
	return &backofficeClient{cc}
}

func (c *backofficeClient) HasAccess(ctx context.Context, in *HasAccessIn, opts ...grpc.CallOption) (*HasAccessOut, error) {
	out := new(HasAccessOut)
	err := c.cc.Invoke(ctx, Backoffice_HasAccess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GameList(ctx context.Context, in *GameListIn, opts ...grpc.CallOption) (*GameListOut, error) {
	out := new(GameListOut)
	err := c.cc.Invoke(ctx, Backoffice_GameList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GameListFull(ctx context.Context, in *GameListIn, opts ...grpc.CallOption) (*GameListOutFull, error) {
	out := new(GameListOutFull)
	err := c.cc.Invoke(ctx, Backoffice_GameListFull_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetProvider(ctx context.Context, in *GetProviderIn, opts ...grpc.CallOption) (*GetProviderOut, error) {
	out := new(GetProviderOut)
	err := c.cc.Invoke(ctx, Backoffice_GetProvider_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) HealthCheck(ctx context.Context, opts ...grpc.CallOption) (Backoffice_HealthCheckClient, error) {
	stream, err := c.cc.NewStream(ctx, &Backoffice_ServiceDesc.Streams[0], Backoffice_HealthCheck_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &backofficeHealthCheckClient{stream}
	return x, nil
}

type Backoffice_HealthCheckClient interface {
	Send(*Status) error
	Recv() (*Status, error)
	grpc.ClientStream
}

type backofficeHealthCheckClient struct {
	grpc.ClientStream
}

func (x *backofficeHealthCheckClient) Send(m *Status) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backofficeHealthCheckClient) Recv() (*Status, error) {
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backofficeClient) GetIntegratorGameSettings(ctx context.Context, in *IntegratorGameSettingsIn, opts ...grpc.CallOption) (*IntegratorGameSettingsOut, error) {
	out := new(IntegratorGameSettingsOut)
	err := c.cc.Invoke(ctx, Backoffice_GetIntegratorGameSettings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetGameData(ctx context.Context, in *GameDataByIntegratorName, opts ...grpc.CallOption) (*Game, error) {
	out := new(Game)
	err := c.cc.Invoke(ctx, Backoffice_GetGameData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetGameDataByApi(ctx context.Context, in *HasAccessIn, opts ...grpc.CallOption) (*Game, error) {
	out := new(Game)
	err := c.cc.Invoke(ctx, Backoffice_GetGameDataByApi_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetCurrencies(ctx context.Context, in *CurrenciesIn, opts ...grpc.CallOption) (*CurrenciesOut, error) {
	out := new(CurrenciesOut)
	err := c.cc.Invoke(ctx, Backoffice_GetCurrencies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetMultiplierByCurrency(ctx context.Context, in *GetMultiplierIn, opts ...grpc.CallOption) (*GetMultiplierOut, error) {
	out := new(GetMultiplierOut)
	err := c.cc.Invoke(ctx, Backoffice_GetMultiplierByCurrency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backofficeClient) GetIntegratorApiKey(ctx context.Context, in *IntegratorApiKeyIn, opts ...grpc.CallOption) (*IntegratorApiKeyOut, error) {
	out := new(IntegratorApiKeyOut)
	err := c.cc.Invoke(ctx, Backoffice_GetIntegratorApiKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackofficeServer is the server API for Backoffice service.
// All implementations must embed UnimplementedBackofficeServer
// for forward compatibility
type BackofficeServer interface {
	HasAccess(context.Context, *HasAccessIn) (*HasAccessOut, error)
	GameList(context.Context, *GameListIn) (*GameListOut, error)
	GameListFull(context.Context, *GameListIn) (*GameListOutFull, error)
	GetProvider(context.Context, *GetProviderIn) (*GetProviderOut, error)
	HealthCheck(Backoffice_HealthCheckServer) error
	GetIntegratorGameSettings(context.Context, *IntegratorGameSettingsIn) (*IntegratorGameSettingsOut, error)
	GetGameData(context.Context, *GameDataByIntegratorName) (*Game, error)
	GetGameDataByApi(context.Context, *HasAccessIn) (*Game, error)
	GetCurrencies(context.Context, *CurrenciesIn) (*CurrenciesOut, error)
	GetMultiplierByCurrency(context.Context, *GetMultiplierIn) (*GetMultiplierOut, error)
	GetIntegratorApiKey(context.Context, *IntegratorApiKeyIn) (*IntegratorApiKeyOut, error)
	mustEmbedUnimplementedBackofficeServer()
}

// UnimplementedBackofficeServer must be embedded to have forward compatible implementations.
type UnimplementedBackofficeServer struct {
}

func (UnimplementedBackofficeServer) HasAccess(context.Context, *HasAccessIn) (*HasAccessOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasAccess not implemented")
}
func (UnimplementedBackofficeServer) GameList(context.Context, *GameListIn) (*GameListOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameList not implemented")
}
func (UnimplementedBackofficeServer) GameListFull(context.Context, *GameListIn) (*GameListOutFull, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameListFull not implemented")
}
func (UnimplementedBackofficeServer) GetProvider(context.Context, *GetProviderIn) (*GetProviderOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProvider not implemented")
}
func (UnimplementedBackofficeServer) HealthCheck(Backoffice_HealthCheckServer) error {
	return status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedBackofficeServer) GetIntegratorGameSettings(context.Context, *IntegratorGameSettingsIn) (*IntegratorGameSettingsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegratorGameSettings not implemented")
}
func (UnimplementedBackofficeServer) GetGameData(context.Context, *GameDataByIntegratorName) (*Game, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameData not implemented")
}
func (UnimplementedBackofficeServer) GetGameDataByApi(context.Context, *HasAccessIn) (*Game, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameDataByApi not implemented")
}
func (UnimplementedBackofficeServer) GetCurrencies(context.Context, *CurrenciesIn) (*CurrenciesOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrencies not implemented")
}
func (UnimplementedBackofficeServer) GetMultiplierByCurrency(context.Context, *GetMultiplierIn) (*GetMultiplierOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMultiplierByCurrency not implemented")
}
func (UnimplementedBackofficeServer) GetIntegratorApiKey(context.Context, *IntegratorApiKeyIn) (*IntegratorApiKeyOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegratorApiKey not implemented")
}
func (UnimplementedBackofficeServer) mustEmbedUnimplementedBackofficeServer() {}

// UnsafeBackofficeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackofficeServer will
// result in compilation errors.
type UnsafeBackofficeServer interface {
	mustEmbedUnimplementedBackofficeServer()
}

func RegisterBackofficeServer(s grpc.ServiceRegistrar, srv BackofficeServer) {
	s.RegisterService(&Backoffice_ServiceDesc, srv)
}

func _Backoffice_HasAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasAccessIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).HasAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_HasAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).HasAccess(ctx, req.(*HasAccessIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GameList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameListIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GameList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GameList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GameList(ctx, req.(*GameListIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GameListFull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameListIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GameListFull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GameListFull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GameListFull(ctx, req.(*GameListIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProviderIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetProvider(ctx, req.(*GetProviderIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_HealthCheck_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackofficeServer).HealthCheck(&backofficeHealthCheckServer{stream})
}

type Backoffice_HealthCheckServer interface {
	Send(*Status) error
	Recv() (*Status, error)
	grpc.ServerStream
}

type backofficeHealthCheckServer struct {
	grpc.ServerStream
}

func (x *backofficeHealthCheckServer) Send(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backofficeHealthCheckServer) Recv() (*Status, error) {
	m := new(Status)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Backoffice_GetIntegratorGameSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratorGameSettingsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetIntegratorGameSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetIntegratorGameSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetIntegratorGameSettings(ctx, req.(*IntegratorGameSettingsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetGameData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameDataByIntegratorName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetGameData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetGameData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetGameData(ctx, req.(*GameDataByIntegratorName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetGameDataByApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasAccessIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetGameDataByApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetGameDataByApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetGameDataByApi(ctx, req.(*HasAccessIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrenciesIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetCurrencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetCurrencies(ctx, req.(*CurrenciesIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetMultiplierByCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMultiplierIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetMultiplierByCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetMultiplierByCurrency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetMultiplierByCurrency(ctx, req.(*GetMultiplierIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backoffice_GetIntegratorApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegratorApiKeyIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackofficeServer).GetIntegratorApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Backoffice_GetIntegratorApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackofficeServer).GetIntegratorApiKey(ctx, req.(*IntegratorApiKeyIn))
	}
	return interceptor(ctx, in, info, handler)
}

// Backoffice_ServiceDesc is the grpc.ServiceDesc for Backoffice service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Backoffice_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "backoffice.Backoffice",
	HandlerType: (*BackofficeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HasAccess",
			Handler:    _Backoffice_HasAccess_Handler,
		},
		{
			MethodName: "GameList",
			Handler:    _Backoffice_GameList_Handler,
		},
		{
			MethodName: "GameListFull",
			Handler:    _Backoffice_GameListFull_Handler,
		},
		{
			MethodName: "GetProvider",
			Handler:    _Backoffice_GetProvider_Handler,
		},
		{
			MethodName: "GetIntegratorGameSettings",
			Handler:    _Backoffice_GetIntegratorGameSettings_Handler,
		},
		{
			MethodName: "GetGameData",
			Handler:    _Backoffice_GetGameData_Handler,
		},
		{
			MethodName: "GetGameDataByApi",
			Handler:    _Backoffice_GetGameDataByApi_Handler,
		},
		{
			MethodName: "GetCurrencies",
			Handler:    _Backoffice_GetCurrencies_Handler,
		},
		{
			MethodName: "GetMultiplierByCurrency",
			Handler:    _Backoffice_GetMultiplierByCurrency_Handler,
		},
		{
			MethodName: "GetIntegratorApiKey",
			Handler:    _Backoffice_GetIntegratorApiKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HealthCheck",
			Handler:       _Backoffice_HealthCheck_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/backoffice/main.proto",
}
